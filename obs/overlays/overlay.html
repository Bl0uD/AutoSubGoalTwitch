<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <title>SubCount Auto - Unified Overlay</title>
    <style>
        /* Police Sea - cherche dans les polices install√©es */
        @font-face {
            font-family: 'Sea';
            src: local('Sea'), local('Sea-Regular'), local('SEA');
            font-display: swap;
        }
        
        :root {
            /* Variables CSS dynamiques (modifi√©es par le serveur JS) */
            --font-family: 'Arial';
            --font-size: 64px;
            --font-weight: normal;
            --text-color: white;
            --shadow-color: rgba(0,0,0,0.5);
            --stroke-color: black;
            --anim-duration: 1s;
            --anim-easing: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --padding-left: 20px;
            --padding-right: 20px;
            --gap: 0;
            /* Alignement dynamique bas√© sur le param√®tre 'align' */
            --justify-content: flex-start;
        }
        
        body {
            background: transparent;
            margin: 0;
            font-family: var(--font-family), Arial, system-ui, sans-serif;
            display: flex;
            justify-content: var(--justify-content);
            align-items: center;
            height: 100vh;
            color: var(--text-color);
            padding-left: var(--padding-left);
            padding-right: var(--padding-right);
        }

        .counter {
            display: flex;
            font-size: var(--font-size);
            font-weight: var(--font-weight);
            gap: var(--gap);
            white-space: pre;
            text-shadow: 3px 3px 3px var(--shadow-color);
            -webkit-text-stroke: 1px var(--stroke-color);
        }

        .digit-container {
            position: relative;
            width: auto;
            min-width: 0.3em;
            height: 1.3em;
            overflow: hidden;
            display: inline-block;
        }

        .space-container {
            width: 0.25em;
            display: inline-block;
        }

        .digit {
            position: absolute;
            width: auto;
            white-space: nowrap;
            left: 0;
            text-align: left;
            transition: transform var(--anim-duration) var(--anim-easing);
        }

        .old { transform: translateY(0); }
        .new { transform: translateY(-100%); }

        .animate .old, .animate .new { animation: none; }

        @keyframes slideOut {
            0%   { transform: translateY(0); }
            100% { transform: translateY(100%); }
        }

        @keyframes slideIn {
            0%   { transform: translateY(-100%); }
            100% { transform: translateY(0); }
        }

        @keyframes slideOutUp {
            0%   { transform: translateY(0); }
            100% { transform: translateY(-100%); }
        }

        @keyframes slideInUp {
            0%   { transform: translateY(100%); }
            100% { transform: translateY(0); }
        }

        .animate-down .old { animation: slideOut 0.4s forwards ease-in-out; }
        .animate-down .new { animation: slideIn 0.4s forwards ease-in-out; }
        .animate-up .old { animation: slideOutUp 0.4s forwards ease-in-out; }
        .animate-up .new { animation: slideInUp 0.4s forwards ease-in-out; }

        /* Animations pour transition directe (batch) */
        .count-exit { animation: fadeSlideOut 0.3s forwards ease-in-out; }
        .count-enter { animation: fadeSlideIn 0.3s forwards ease-in-out; }

        @keyframes fadeSlideOut {
            0%   { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(50%); }
        }

        @keyframes fadeSlideIn {
            0%   { opacity: 0; transform: translateY(-50%); }
            100% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="counter" id="counter">...</div>

    <script>
        // ==================================================================
        // üîß CONFIGURATION VIA PARAM√àTRES URL
        // ==================================================================
        // Usage: overlay.html?type=follow&align=left
        // - type: 'follow' ou 'sub' (d√©faut: 'follow')
        // - align: 'left' ou 'right' (d√©faut: 'left')
        // ==================================================================
        
        const urlParams = new URLSearchParams(window.location.search);
        const OVERLAY_TYPE = urlParams.get('type') || 'follow'; // 'follow' ou 'sub'
        const OVERLAY_ALIGN = urlParams.get('align') || 'left'; // 'left' ou 'right'
        
        // Configuration dynamique bas√©e sur les param√®tres
        const CONFIG = {
            type: OVERLAY_TYPE === 'sub' ? 'sub' : 'follow',
            align: OVERLAY_ALIGN === 'right' ? 'right' : 'left',
            wsEventType: OVERLAY_TYPE === 'sub' ? 'sub_update' : 'follow_update',
            apiEndpoint: OVERLAY_TYPE === 'sub' ? '/api/sub_goal' : '/api/follow_goal',
        };
        
        console.log(`üéØ Overlay configur√©: type=${CONFIG.type}, align=${CONFIG.align}`);
        console.log(`üì° √âcoute: ${CONFIG.wsEventType}, API: ${CONFIG.apiEndpoint}`);
        
        // Appliquer l'alignement
        document.documentElement.style.setProperty(
            '--justify-content', 
            CONFIG.align === 'right' ? 'flex-end' : 'flex-start'
        );
        
        // ==================================================================
        // üöÄ SYST√àME DE D√âMARRAGE SIMPLIFI√â
        // ==================================================================
        // Le script Python OBS g√®re le refresh des sources navigateur.
        // L'overlay doit juste attendre le serveur et charger les donn√©es.
        // ==================================================================
        
        let isServerReady = false;
        let isDataLoaded = false;
        let startupRetryCount = 0;
        const MAX_STARTUP_RETRIES = 30; // 30 tentatives = 30 secondes max
        const STARTUP_RETRY_DELAY = 1000; // 1 seconde entre les tentatives
        
        async function waitForServer() {
            console.log('‚è≥ Attente du serveur...');
            
            while (!isServerReady && startupRetryCount < MAX_STARTUP_RETRIES) {
                startupRetryCount++;
                try {
                    const response = await fetch('http://localhost:8082/api/status', {
                        method: 'GET',
                        cache: 'no-store'
                    });
                    if (response.ok) {
                        isServerReady = true;
                        console.log(`‚úÖ Serveur pr√™t apr√®s ${startupRetryCount} tentative(s)`);
                        return true;
                    }
                } catch (error) {
                    if (startupRetryCount % 5 === 0) {
                        console.log(`‚è≥ Tentative ${startupRetryCount}/${MAX_STARTUP_RETRIES}...`);
                    }
                }
                await new Promise(resolve => setTimeout(resolve, STARTUP_RETRY_DELAY));
            }
            
            if (!isServerReady) {
                console.error('‚ùå Serveur non disponible apr√®s 30 tentatives');
            }
            return isServerReady;
        }
        
        async function initializeOverlay() {
            console.log('üöÄ Initialisation de l\'overlay...');
            counterEl.textContent = '...';
            
            // 1. Attendre que le serveur soit pr√™t
            const serverReady = await waitForServer();
            if (!serverReady) {
                counterEl.textContent = '...';
                // R√©essayer dans 5 secondes
                setTimeout(initializeOverlay, 5000);
                return;
            }
            
            console.log('‚úÖ Serveur pr√™t, chargement des donn√©es...');
            
            // 2. Charger la config initiale
            await loadInitialConfig();
            
            // 3. Connecter les WebSockets
            connectConfigWebSocket();
            connectWebSocket();
            
            // 4. Attendre les donn√©es via WebSocket
            await waitForInitialData(2000);
            
            // 5. Si pas de donn√©es, fetch direct
            if (!currentText || currentText === '...' || currentText === '') {
                console.log('‚ö†Ô∏è Donn√©es non re√ßues via WS, fetch direct...');
                await fetchAndDisplayDirect();
            }
            
            // 6. Recalcul apr√®s stabilisation
            setTimeout(forceRecalculateDisplay, 500);
            
            console.log('‚úÖ Overlay initialis√©:', currentText);
        }
        
        async function fetchAndDisplayDirect() {
            try {
                const response = await fetch(`http://localhost:8082${CONFIG.apiEndpoint}?_=${Date.now()}`, {
                    cache: 'no-store'
                });
                if (response.ok) {
                    const data = await response.json();
                    console.log('üì• Donn√©es re√ßues:', data);
                    if (data.goal) {
                        currentGoal = data.goal;
                        previousCount = data.goal.current;
                        displayGoalText(data.goal);
                        isDataLoaded = true;
                    }
                }
            } catch (error) {
                console.error('‚ùå Erreur fetch:', error);
            }
        }
        
        async function waitForInitialData(timeout = 2000) {
            const startTime = Date.now();
            while (!isDataLoaded && (Date.now() - startTime) < timeout) {
                if (currentText && currentText !== '...' && currentText !== '') {
                    isDataLoaded = true;
                    return true;
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            if (!isDataLoaded) {
                await fetchCurrentDataWithRetry(3);
            }
            return isDataLoaded;
        }
        
        async function fetchCurrentDataWithRetry(maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const success = await fetchCurrentData();
                    if (success) {
                        isDataLoaded = true;
                        return true;
                    }
                } catch (error) {
                    console.log(`‚è≥ Retry ${i + 1}/${maxRetries}...`);
                }
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            return false;
        }
        
        // ==================================================================
        // üé® CONNEXION WEBSOCKET POUR CONFIGURATION DYNAMIQUE
        // ==================================================================
        
        let configWs = null;
        let configWsReconnectDelay = 1000;
        
        function connectConfigWebSocket() {
            if (!isServerReady) return;
            
            try {
                configWs = new WebSocket('ws://localhost:8084');
                
                configWs.onopen = () => {
                    console.log('‚úÖ Config WebSocket connect√© (port 8084)');
                    configWsReconnectDelay = 1000; // Reset delay on success
                };
                
                configWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'config_update' && data.config) {
                            console.log('üé® Configuration re√ßue:', data.config);
                            applyConfig(data.config);
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur parsing config:', error);
                    }
                };
                
                configWs.onerror = (error) => {
                    console.error('‚ùå Erreur Config WebSocket:', error);
                };
                
                configWs.onclose = () => {
                    console.log(`üîå Config WebSocket d√©connect√©, reconnexion dans ${configWsReconnectDelay/1000}s...`);
                    setTimeout(connectConfigWebSocket, configWsReconnectDelay);
                    configWsReconnectDelay = Math.min(configWsReconnectDelay * 1.5, 10000);
                };
            } catch (error) {
                console.error('‚ùå Erreur connexion Config WebSocket:', error);
                setTimeout(connectConfigWebSocket, configWsReconnectDelay);
            }
        }
        
        function applyConfig(config) {
            const root = document.documentElement;
            
            // Appliquer la police
            if (config.font) {
                if (config.font.family) root.style.setProperty('--font-family', config.font.family);
                if (config.font.size) root.style.setProperty('--font-size', config.font.size);
                if (config.font.weight) root.style.setProperty('--font-weight', config.font.weight);
            }
            
            // Appliquer les couleurs
            if (config.colors) {
                if (config.colors.text) root.style.setProperty('--text-color', config.colors.text);
                if (config.colors.shadow) root.style.setProperty('--shadow-color', config.colors.shadow);
                if (config.colors.stroke) root.style.setProperty('--stroke-color', config.colors.stroke);
            }
            
            // Appliquer l'animation
            if (config.animation) {
                if (config.animation.duration) root.style.setProperty('--anim-duration', config.animation.duration);
                if (config.animation.easing) root.style.setProperty('--anim-easing', config.animation.easing);
            }
            
            // Appliquer la mise en page
            if (config.layout) {
                if (config.layout.paddingLeft) root.style.setProperty('--padding-left', config.layout.paddingLeft);
                if (config.layout.paddingRight) root.style.setProperty('--padding-right', config.layout.paddingRight);
                if (config.layout.gap) root.style.setProperty('--gap', config.layout.gap);
            }
            
            console.log('‚úÖ Configuration appliqu√©e avec succ√®s');
            setTimeout(forceRecalculateDisplay, 100);
        }
        
        async function loadInitialConfig() {
            try {
                const response = await fetch('http://localhost:8082/api/overlay-config', {
                    cache: 'no-store'
                });
                if (response.ok) {
                    const config = await response.json();
                    console.log('üé® Configuration initiale charg√©e:', config);
                    applyConfig(config);
                    return true;
                }
            } catch (error) {
                console.error('‚ùå Erreur chargement config initiale:', error);
            }
            return false;
        }
        
        // ==================================================================
        // üìä WEBSOCKET COMPTEUR ET ANIMATIONS
        // ==================================================================
        
        let ws;
        let wsReconnectDelay = 1000;
        const counterEl = document.getElementById("counter");
        let currentText = "";
        let previousCount = null;
        let animationDirection = "down";
        let currentGoal = null;
        let isAnimating = false;
        let animationQueue = [];

        function createDigitElement(char, className, delay) {
            const div = document.createElement("div");
            div.className = className + " digit";
            div.textContent = char;
            div.style.animationDelay = `${delay}ms`;
            return div;
        }

        function updateCounter(newText) {
            if (newText === currentText) return;

            const chars = newText.split("");
            counterEl.innerHTML = "";
            
            // Div de mesure avec les m√™mes styles que counter
            const measureDiv = document.createElement("div");
            measureDiv.style.visibility = "hidden";
            measureDiv.style.position = "absolute";
            measureDiv.style.whiteSpace = "nowrap";
            measureDiv.style.display = "inline-block";
            
            const counterStyles = getComputedStyle(counterEl);
            measureDiv.style.fontSize = counterStyles.fontSize;
            measureDiv.style.fontFamily = counterStyles.fontFamily;
            measureDiv.style.fontWeight = counterStyles.fontWeight;
            measureDiv.style.fontStyle = counterStyles.fontStyle;
            measureDiv.style.letterSpacing = counterStyles.letterSpacing;
            measureDiv.style.textShadow = counterStyles.textShadow;
            measureDiv.style.webkitTextStroke = counterStyles.webkitTextStroke;
            
            document.body.appendChild(measureDiv);

            const totalChars = Math.max(chars.length, currentText.length);
            let changedCount = 0;

            for (let i = 0; i < totalChars; i++) {
                if ((currentText[i] || "") !== (chars[i] || "")) {
                    changedCount++;
                }
            }

            const changeRatio = changedCount / totalChars;
            const isFullReset = changeRatio > 0.5;

            chars.forEach((char, index) => {
                if (char === " ") {
                    const spaceContainer = document.createElement("div");
                    spaceContainer.className = "space-container";
                    spaceContainer.innerHTML = "&nbsp;";
                    counterEl.appendChild(spaceContainer);
                } else {
                    const container = document.createElement("div");
                    container.className = "digit-container";

                    measureDiv.textContent = char;
                    const charWidth = measureDiv.getBoundingClientRect().width;
                    container.style.width = `${Math.max(charWidth, 10)}px`;

                    const currentChar = currentText[index] || "";
                    const charChanged = char !== currentChar;
                    const delay = isFullReset ? 0 : index * 50;

                    if (!charChanged && !isFullReset) {
                        const staticDigit = createDigitElement(char, "static", 0);
                        staticDigit.style.transform = "translateY(0)";
                        container.appendChild(staticDigit);
                    } else {
                        const oldDigit = createDigitElement(currentChar === " " ? " " : currentChar, "old", delay);
                        const newDigit = createDigitElement(char, "new", delay);

                        container.appendChild(oldDigit);
                        container.appendChild(newDigit);
                        container.classList.add("animate");
                        container.classList.add(`animate-${animationDirection}`);
                    }

                    counterEl.appendChild(container);
                }
            });

            document.body.removeChild(measureDiv);
            currentText = newText;
        }
        
        function animateCounterProgressive(fromCount, toCount, goal, direction) {
            const steps = Math.abs(toCount - fromCount);
            
            if (steps === 0) {
                displayGoalText(goal, direction);
                return;
            }
            
            const totalDuration = 1000;
            const startTime = performance.now();
            
            console.log(`üé∞ Animation: ${fromCount} ‚Üí ${toCount} (${steps} √©tapes)`);
            
            let lastDisplayedValue = fromCount;
            
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / totalDuration, 1);
                const easedProgress = easeOutCubic(progress);
                const currentValue = Math.round(fromCount + (toCount - fromCount) * easedProgress);
                
                if (currentValue !== lastDisplayedValue || progress === 1) {
                    lastDisplayedValue = currentValue;
                    const intermediateGoal = { ...goal, current: currentValue };
                    displayGoalText(intermediateGoal, direction);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    const finalGoal = { ...goal, current: toCount };
                    displayGoalText(finalGoal, direction);
                    isAnimating = false;
                    processAnimationQueue();
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function displayGoalText(goal, direction = null) {
            if (direction !== null) {
                animationDirection = direction;
            }
            
            let displayText;
            
            if (goal.isMaxReached) {
                displayText = goal.current.toString();
            } else {
                if (!goal.message || goal.message.trim() === '') {
                    displayText = `${goal.current}/${goal.target}`;
                } else {
                    displayText = `${goal.current}/${goal.target} : ${goal.message}`;
                }
            }
            
            updateCounter(displayText);
        }
        
        function processAnimationQueue() {
            if (animationQueue.length > 0 && !isAnimating) {
                const nextAnimation = animationQueue.shift();
                isAnimating = true;
                animateCounterProgressive(nextAnimation.from, nextAnimation.to, nextAnimation.goal, nextAnimation.direction);
            }
        }

        function connectWebSocket() {
            if (!isServerReady) return;
            
            try {
                ws = new WebSocket('ws://localhost:8083');

                ws.onopen = () => {
                    console.log('‚úÖ Connect√© au WebSocket (compteur)');
                    wsReconnectDelay = 1000; // Reset delay on success
                    // Le serveur envoie automatiquement les donn√©es initiales √† la connexion
                    // Backup: si pas re√ßu apr√®s 500ms, fetch via API
                    setTimeout(() => {
                        if (!isDataLoaded) {
                            console.log('‚è≥ Donn√©es initiales non re√ßues, fetch via API...');
                            fetchCurrentData().then(success => {
                                if (success) {
                                    isDataLoaded = true;
                                }
                            });
                        }
                    }, 500);
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        // Filtrer selon le type d'overlay configur√©
                        if (data.type === CONFIG.wsEventType && data.goal) {
                            // Si c'est un message initial, ne pas animer
                            if (data.isInitial) {
                                console.log('üì• Donn√©es initiales re√ßues via WebSocket');
                                currentGoal = data.goal;
                                previousCount = data.goal.current;
                                displayGoalText(data.goal);
                                isDataLoaded = true;
                            } else {
                                updateGoal(data.goal, {
                                    batchCount: data.batchCount || 1,
                                    isBatch: data.isBatch || false
                                });
                            }
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur parsing message:', error);
                    }
                };

                ws.onerror = (error) => {
                    console.error('‚ùå Erreur WebSocket (compteur):', error);
                };

                ws.onclose = () => {
                    console.log(`üîå WebSocket compteur d√©connect√©, reconnexion dans ${wsReconnectDelay/1000}s...`);
                    // Reset isDataLoaded pour forcer un rechargement √† la reconnexion
                    isDataLoaded = false;
                    setTimeout(connectWebSocket, wsReconnectDelay);
                    wsReconnectDelay = Math.min(wsReconnectDelay * 1.5, 10000);
                };
            } catch (error) {
                console.error('‚ùå Erreur connexion WebSocket:', error);
                setTimeout(connectWebSocket, wsReconnectDelay);
            }
        }
        
        async function fetchCurrentData() {
            try {
                const cacheBuster = Date.now();
                const response = await fetch(`http://localhost:8082${CONFIG.apiEndpoint}?_=${cacheBuster}`, {
                    cache: 'no-store'
                });
                if (response.ok) {
                    const data = await response.json();
                    if (data.goal) {
                        updateGoal(data.goal);
                        return true;
                    }
                }
            } catch (error) {
                console.error(`‚ùå Erreur r√©cup√©ration donn√©es ${CONFIG.type} goal:`, error);
            }
            return false;
        }
        
        function updateGoal(goal, batchInfo = {}) {
            currentGoal = goal;

            if (previousCount !== null && goal.current !== previousCount) {
                const delta = goal.current - previousCount;
                const direction = delta > 0 ? "down" : "up";
                const absDelta = Math.abs(delta);
                
                console.log(`üîÑ Direction: ${direction} (${previousCount} ‚Üí ${goal.current})`);

                // Animation slot-machine si: batch avec plusieurs events OU delta > 1
                const shouldUseSlotMachine = (batchInfo.isBatch && Math.abs(batchInfo.batchCount) > 1) || absDelta > 1;
                
                if (shouldUseSlotMachine) {
                    console.log(`üé∞ SLOT-MACHINE: ${previousCount} -> ${goal.current}`);
                    animationQueue = [];
                    animateSlotMachine(previousCount, goal.current, goal, direction);
                } else {
                    console.log(`üìä PROGRESSIVE: ${previousCount} -> ${goal.current}`);
                    animationQueue.push({
                        from: previousCount,
                        to: goal.current,
                        goal: goal,
                        direction: direction
                    });

                    if (!isAnimating) {
                        isAnimating = true;
                        const animation = animationQueue.shift();
                        animateCounterProgressive(animation.from, animation.to, animation.goal, animation.direction);
                    }
                }
            } else {
                displayGoalText(goal);
            }

            previousCount = goal.current;
            console.log(`üìä ${CONFIG.type} goal mis √† jour`);
        }
        
        /**
         * SLOT-MACHINE animation for grouped changes
         * Sequential scrolling effect: 390 -> 391 -> 392 -> ... -> 401
         * 
         * Plafonnement pour les grands deltas:
         * - Follows: max 50 √©tapes visuelles (dur√©e ~1.5s)
         * - Subs: max 200 √©tapes visuelles (dur√©e ~1.5s)
         */
        function animateSlotMachine(from, to, goal, direction) {
            console.log(`üé∞ Starting slot-machine: ${from} -> ${to}`);
            isAnimating = true;
            
            const delta = to - from;
            const absDelta = Math.abs(delta);
            const stepSign = delta > 0 ? 1 : -1;
            
            // Limites selon le type d'overlay (follows = 50, subs = 200)
            const maxVisualSteps = CONFIG.type === 'sub' ? 200 : 50;
            const FIXED_DURATION = 1500; // 1.5 secondes max pour grands deltas
            
            // Si delta > limite, on r√©duit le nombre d'√©tapes visuelles
            const visualSteps = Math.min(absDelta, maxVisualSteps);
            const skipFactor = absDelta > maxVisualSteps ? Math.ceil(absDelta / maxVisualSteps) : 1;
            
            // Dur√©e totale: proportionnelle aux √©tapes visuelles, plafonn√©e √† 1.5s
            const totalDuration = Math.min(Math.max(visualSteps * 80, 500), FIXED_DURATION);
            
            console.log(`üìä Delta: ${absDelta}, Visual steps: ${visualSteps}, Skip: ${skipFactor}, Duration: ${totalDuration}ms`);
            
            let currentValue = from;
            let stepIndex = 0;
            
            function easeInOutQuad(t) {
                return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            }
            
            function getDelayForStep(index, total) {
                const progressBefore = index / total;
                const progressAfter = (index + 1) / total;
                const easedBefore = easeInOutQuad(progressBefore);
                const easedAfter = easeInOutQuad(progressAfter);
                const stepDuration = (easedAfter - easedBefore) * totalDuration;
                return Math.max(stepDuration, 20);
            }
            
            function displayStep() {
                animationDirection = direction;
                const intermediateGoal = { ...goal, current: currentValue };
                displayGoalText(intermediateGoal);
                
                // Calculer la prochaine valeur (avec saut si n√©cessaire)
                const remaining = Math.abs(to - currentValue);
                
                if (remaining > 0) {
                    // Sauter des valeurs si delta trop grand
                    const nextStep = Math.min(skipFactor, remaining) * stepSign;
                    currentValue += nextStep;
                    stepIndex++;
                    
                    const delay = getDelayForStep(stepIndex, visualSteps);
                    setTimeout(displayStep, delay);
                } else {
                    finishAnimation();
                }
            }
            
            function finishAnimation() {
                // S'assurer qu'on affiche bien la valeur finale
                animationDirection = direction;
                displayGoalText(goal);
                console.log(`‚úÖ Slot-machine completed: ${to} (${visualSteps} visual steps in ${totalDuration}ms)`);
                isAnimating = false;
                
                if (animationQueue.length > 0) {
                    const next = animationQueue.shift();
                    isAnimating = true;
                    animateCounterProgressive(next.from, next.to, next.goal, next.direction);
                }
            }
            
            displayStep();
        }

        function forceRecalculateDisplay() {
            if (!currentText || currentText === '...' || currentText === 'Chargement...') {
                // Si pas de texte, essayer de recharger
                console.log('‚ö†Ô∏è Pas de texte, rechargement...');
                fetchAndDisplayDirect();
                return;
            }
            console.log('üîß Recalcul forc√© des dimensions avec la police actuelle');
            const currentDisplayText = currentText;
            currentText = "";
            counterEl.innerHTML = "";
            void counterEl.offsetHeight;
            updateCounter(currentDisplayText);
        }
        
        // ==================================================================
        // üîÑ V√âRIFICATION P√âRIODIQUE - S'assurer que l'overlay a des donn√©es
        // ==================================================================
        
        let healthCheckInterval = null;
        let healthCheckCount = 0;
        
        function startHealthCheck() {
            // V√©rifier rapidement au d√©but (toutes les 2 secondes pendant 30s)
            // puis toutes les 10 secondes ensuite
            const checkInterval = () => {
                healthCheckCount++;
                const interval = healthCheckCount < 15 ? 2000 : 10000;
                
                // Si pas de donn√©es valides affich√©es et serveur pr√™t
                const needsData = !currentText || 
                                  currentText === '...' || 
                                  currentText === 'Chargement...' ||
                                  currentText === 'Erreur' ||
                                  counterEl.textContent === '...';
                                  
                if (needsData && isServerReady) {
                    console.log(`‚ö†Ô∏è [Check ${healthCheckCount}] Overlay vide, rechargement...`);
                    fetchAndDisplayDirect();
                }
                
                setTimeout(checkInterval, interval);
            };
            
            // D√©marrer apr√®s 3 secondes
            setTimeout(checkInterval, 3000);
        }
        
        // ==================================================================
        // üöÄ INITIALISATION - Attendre que le serveur soit pr√™t
        // ==================================================================
        
        // D√©marrer l'initialisation robuste
        initializeOverlay();
        
        // D√©marrer la v√©rification de sant√© apr√®s un court d√©lai
        setTimeout(startHealthCheck, 5000);
        
        // Note: Plus de refresh p√©riodique n√©cessaire !
        // - Le WebSocket re√ßoit les mises √† jour en temps r√©el
        // - waitForServer() g√®re la reconnexion au d√©marrage
        // - Le polling serveur synchronise toutes les 10s (follows) et 60s (subs)
    </script>
</body>
</html>
</html>
