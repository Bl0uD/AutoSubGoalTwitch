<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <title>Followgoal Right - Dynamic Config</title>
    <style>
        @font-face {
            font-family: 'SEA';
            src: local('SEA'), url('SEA.ttf') format('truetype');
            font-display: swap;
        }
        
        :root {
            /* Variables CSS dynamiques (modifiÃ©es par le serveur JS) */
            --font-family: 'SEA';
            --font-size: 64px;
            --font-weight: normal;
            --text-color: white;
            --shadow-color: rgba(0,0,0,0.5);
            --stroke-color: black;
            --anim-duration: 1s;
            --anim-easing: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --padding-left: 20px;
            --gap: 0;
        }
        
        body {
            background: transparent;
            margin: 0;
            font-family: var(--font-family), 'SEA', system-ui, sans-serif;
            display: flex;
            justify-content: flex-end;
            align-items: center;
            height: 100vh;
            color: var(--text-color);
            padding-right: var(--padding-left);
            padding-left: 0;
        }

        .counter {
            display: flex;
            font-size: var(--font-size);
            font-weight: var(--font-weight);
            gap: var(--gap);
            white-space: pre;
            text-shadow: 3px 3px 3px var(--shadow-color);
            -webkit-text-stroke: 1px var(--stroke-color);
        }

        .digit-container {
            position: relative;
            width: auto;
            min-width: 0.3em;
            height: 1.3em;
            overflow: hidden;
            display: inline-block;
        }

        .space-container {
            width: 0.25em;
            display: inline-block;
        }

        .digit {
            position: absolute;
            width: auto;
            white-space: nowrap;
            left: 0;
            text-align: left;
            transition: transform var(--anim-duration) var(--anim-easing);
        }

        .old {
            transform: translateY(0);
        }

        .new {
            transform: translateY(-100%);
        }

        .animate .old {
            animation: none;
        }

        .animate .new {
            animation: none;
        }

        @keyframes slideOut {
            0%   { transform: translateY(0); }
            100% { transform: translateY(100%); }
        }

        @keyframes slideIn {
            0%   { transform: translateY(-100%); }
            100% { transform: translateY(0); }
        }

        @keyframes slideOutUp {
            0%   { transform: translateY(0); }
            100% { transform: translateY(-100%); }
        }

        @keyframes slideInUp {
            0%   { transform: translateY(100%); }
            100% { transform: translateY(0); }
        }

        .animate-down .old {
            animation: slideOut 0.4s forwards ease-in-out;
        }

        .animate-down .new {
            animation: slideIn 0.4s forwards ease-in-out;
        }

        .animate-up .old {
            animation: slideOutUp 0.4s forwards ease-in-out;
        }

        .animate-up .new {
            animation: slideInUp 0.4s forwards ease-in-out;
        }

        /* Animations pour transition directe (batch) */
        .count-exit {
            animation: fadeSlideOut 0.3s forwards ease-in-out;
        }

        .count-enter {
            animation: fadeSlideIn 0.3s forwards ease-in-out;
        }

        @keyframes fadeSlideOut {
            0%   { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(50%); }
        }

        @keyframes fadeSlideIn {
            0%   { opacity: 0; transform: translateY(-50%); }
            100% { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="counter" id="counter">Chargement...</div>

    <script>
        // ==================================================================
        // ðŸŽ¨ CONNEXION WEBSOCKET POUR CONFIGURATION DYNAMIQUE
        // ==================================================================
        
        let configWs = null;
        
        function connectConfigWebSocket() {
            try {
                configWs = new WebSocket('ws://localhost:8084');
                
                configWs.onopen = () => {
                    console.log('âœ… Config WebSocket connectÃ© (port 8084)');
                };
                
                configWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'config_update' && data.config) {
                            console.log('ðŸŽ¨ Configuration reÃ§ue:', data.config);
                            applyConfig(data.config);
                        }
                    } catch (error) {
                        console.error('âŒ Erreur parsing config:', error);
                    }
                };
                
                configWs.onerror = (error) => {
                    console.error('âŒ Erreur Config WebSocket:', error);
                };
                
                configWs.onclose = () => {
                    console.log('ðŸ”Œ Config WebSocket dÃ©connectÃ©, reconnexion dans 5s...');
                    setTimeout(connectConfigWebSocket, 5000);
                };
            } catch (error) {
                console.error('âŒ Erreur connexion Config WebSocket:', error);
                setTimeout(connectConfigWebSocket, 5000);
            }
        }
        
        function applyConfig(config) {
            const root = document.documentElement;
            
            // Appliquer la police
            if (config.font) {
                if (config.font.family) root.style.setProperty('--font-family', config.font.family);
                if (config.font.size) root.style.setProperty('--font-size', config.font.size);
                if (config.font.weight) root.style.setProperty('--font-weight', config.font.weight);
            }
            
            // Appliquer les couleurs
            if (config.colors) {
                if (config.colors.text) root.style.setProperty('--text-color', config.colors.text);
                if (config.colors.shadow) root.style.setProperty('--shadow-color', config.colors.shadow);
                if (config.colors.stroke) root.style.setProperty('--stroke-color', config.colors.stroke);
            }
            
            // Appliquer l'animation
            if (config.animation) {
                if (config.animation.duration) root.style.setProperty('--anim-duration', config.animation.duration);
                if (config.animation.easing) root.style.setProperty('--anim-easing', config.animation.easing);
            }
            
            // Appliquer la mise en page
            if (config.layout) {
                if (config.layout.paddingLeft) root.style.setProperty('--padding-left', config.layout.paddingLeft);
                if (config.layout.gap) root.style.setProperty('--gap', config.layout.gap);
            }
            
            console.log('âœ… Configuration appliquÃ©e avec succÃ¨s');
            
            // Forcer le rafraÃ®chissement de l'affichage
            setTimeout(forceRecalculateDisplay, 100);
        }
        
        async function loadInitialConfig() {
            try {
                const response = await fetch('http://localhost:8082/api/overlay-config');
                if (response.ok) {
                    const config = await response.json();
                    console.log('ðŸŽ¨ Configuration initiale chargÃ©e:', config);
                    applyConfig(config);
                }
            } catch (error) {
                console.error('âŒ Erreur chargement config initiale:', error);
            }
        }
        
        // Charger la config initiale puis connecter le WebSocket
        loadInitialConfig();
        connectConfigWebSocket();
        
        // ==================================================================
        // RESTE DU CODE ORIGINAL (WebSocket compteur, animations, etc.)
        // ==================================================================
        
        let ws;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        const counterEl = document.getElementById("counter");
        let currentText = "";
        let previousSubCount = null;
        let animationDirection = "down";
        let currentFollowgoal = null;
        let isAnimating = false;
        let animationQueue = [];

        function createDigitElement(char, className, delay) {
            const div = document.createElement("div");
            div.className = className + " digit";
            div.textContent = char;
            div.style.animationDelay = `${delay}ms`;
            return div;
        }

                function updateCounter(newText) {
            if (newText === currentText) return;

            const chars = newText.split("");
            counterEl.innerHTML = "";
            // Créer un div de mesure avec EXACTEMENT les mêmes styles que counter
            const measureDiv = document.createElement("div");
            measureDiv.style.visibility = "hidden";
            measureDiv.style.position = "absolute";
            measureDiv.style.whiteSpace = "nowrap";
            measureDiv.style.display = "inline-block";
            
            // Copier TOUS les styles computés du counter (la clé pour une mesure exacte)
            const counterStyles = getComputedStyle(counterEl);
            measureDiv.style.fontSize = counterStyles.fontSize;
            measureDiv.style.fontFamily = counterStyles.fontFamily;
            measureDiv.style.fontWeight = counterStyles.fontWeight;
            measureDiv.style.fontStyle = counterStyles.fontStyle;
            measureDiv.style.letterSpacing = counterStyles.letterSpacing;
            measureDiv.style.textShadow = counterStyles.textShadow;
            measureDiv.style.webkitTextStroke = counterStyles.webkitTextStroke;
            
            console.log(` Mesure avec styles computés: ${counterStyles.fontFamily} ${counterStyles.fontSize}`);
            
            document.body.appendChild(measureDiv);

            const totalChars = Math.max(chars.length, currentText.length);
            let changedCount = 0;

            for (let i = 0; i < totalChars; i++) {
                if ((currentText[i] || "") !== (chars[i] || "")) {
                    changedCount++;
                }
            }

            const changeRatio = changedCount / totalChars;
            const isFullReset = changeRatio > 0.5;

            chars.forEach((char, index) => {
                if (char === " ") {
                    const spaceContainer = document.createElement("div");
                    spaceContainer.className = "space-container";
                    spaceContainer.innerHTML = "&nbsp;";
                    counterEl.appendChild(spaceContainer);
                } else {
                    const container = document.createElement("div");
                    container.className = "digit-container";

                    // Mesurer avec getBoundingClientRect() car measureDiv a les MÊMES styles
                    measureDiv.textContent = char;
                    const charWidth = measureDiv.getBoundingClientRect().width;
                    container.style.width = `${Math.max(charWidth, 10)}px`;

                    const currentChar = currentText[index] || "";
                    const charChanged = char !== currentChar;
                    const delay = isFullReset ? 0 : index * 50;

                    if (!charChanged && !isFullReset) {
                        const staticDigit = createDigitElement(char, "static", 0);
                        staticDigit.style.transform = "translateY(0)";
                        container.appendChild(staticDigit);
                    } else {
                        const oldDigit = createDigitElement(currentChar === " " ? " " : currentChar, "old", delay);
                        const newDigit = createDigitElement(char, "new", delay);

                        container.appendChild(oldDigit);
                        container.appendChild(newDigit);
                        container.classList.add("animate");
                        container.classList.add(`animate-${animationDirection}`);
                    }

                    counterEl.appendChild(container);
                }
            });

            document.body.removeChild(measureDiv);
            currentText = newText;
        }
        
        function animateCounterProgressive(fromCount, toCount, goal, direction) {
            const steps = Math.abs(toCount - fromCount);
            
            if (steps === 0) {
                displayGoalText(goal, direction);
                return;
            }
            
            const totalDuration = 1000;
            const startTime = performance.now();
            const updateInterval = totalDuration / Math.max(steps, 60);
            
            console.log(`ðŸŽ° Animation: ${fromCount} â†’ ${toCount} (${steps} Ã©tapes)`);
            
            let lastDisplayedValue = fromCount;
            
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / totalDuration, 1);
                const easedProgress = easeOutCubic(progress);
                const currentValue = Math.round(fromCount + (toCount - fromCount) * easedProgress);
                
                if (currentValue !== lastDisplayedValue || progress === 1) {
                    lastDisplayedValue = currentValue;
                    const intermediateGoal = { ...goal, current: currentValue };
                    displayGoalText(intermediateGoal, direction);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    const finalGoal = { ...goal, current: toCount };
                    displayGoalText(finalGoal, direction);
                    isAnimating = false;
                    processAnimationQueue();
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function displayGoalText(goal, direction = null) {
            // Si une direction est fournie (ex: animate from queue), l'appliquer
            if (direction !== null) {
                animationDirection = direction;
            }
            let displayText;
            
            if (goal.isMaxReached) {
                displayText = goal.current.toString();
            } else {
                if (!goal.message || goal.message.trim() === '') {
                    displayText = `${goal.current}/${goal.target}`;
                } else {
                    displayText = `${goal.current}/${goal.target} : ${goal.message}`;
                }
            }
            
            updateCounter(displayText);
        }
        
        function processAnimationQueue() {
            if (animationQueue.length > 0 && !isAnimating) {
                const nextAnimation = animationQueue.shift();
                isAnimating = true;
                animateCounterProgressive(nextAnimation.from, nextAnimation.to, nextAnimation.goal, nextAnimation.direction);
            }
        }

        function connectWebSocket() {
            try {
                ws = new WebSocket('ws://localhost:8083');

                ws.onopen = () => {
                    console.log('âœ… ConnectÃ© au WebSocket (compteur)');
                    reconnectAttempts = 0;
                    fetchCurrentData();
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'follow_update' && data.goal) {
                            // Passer les infos de batch si disponibles
                            const batchInfo = {
                                batchCount: data.batchCount || 0,
                                isBatch: data.isBatch || false,
                                isRemoval: data.isRemoval || false
                            };
                            updateFollowgoal(data.goal, batchInfo);
                        }
                    } catch (error) {
                        console.error('âŒ Erreur parsing message:', error);
                    }
                };

                ws.onerror = (error) => {
                    console.error('âŒ Erreur WebSocket (compteur):', error);
                };

                ws.onclose = () => {
                    console.log('ðŸ”Œ WebSocket compteur dÃ©connectÃ©, reconnexion dans 3s...');
                    setTimeout(connectWebSocket, 3000);
                };
            } catch (error) {
                console.error('âŒ Erreur connexion WebSocket:', error);
                setTimeout(connectWebSocket, 3000);
            }
        }
        
        async function fetchCurrentData() {
            try {
                const cacheBuster = Date.now();
                const response = await fetch(`http://localhost:8082/api/follow_goal?_=${cacheBuster}`);
                if (response.ok) {
                    const data = await response.json();
                    updateFollowgoal(data.goal);
                }
            } catch (error) {
                console.error('âŒ Erreur rÃ©cupÃ©ration donnÃ©es FOLLOW goal:', error);
            }
        }
        
        function updateFollowgoal(goal, batchInfo = {}) {
            currentFollowgoal = goal;

            if (previousSubCount !== null && goal.current !== previousSubCount) {
                const delta = goal.current - previousSubCount;
                const direction = delta > 0 ? "down" : "up";
                const absDelta = Math.abs(delta);
                
                console.log(`ðŸ”„ Direction: ${direction} (${previousSubCount} â†’ ${goal.current}), delta: ${delta}`);
                console.log(`ðŸ“¦ BatchInfo: isBatch=${batchInfo.isBatch}, batchCount=${batchInfo.batchCount}, isRemoval=${batchInfo.isRemoval}`);

                // DÃ©cider du type d'animation basÃ© sur le batch ET le delta
                // Animation slot-machine si: batch avec plusieurs events OU delta > 1
                const shouldUseSlotMachine = (batchInfo.isBatch && Math.abs(batchInfo.batchCount) > 1) || absDelta > 1;
                
                if (shouldUseSlotMachine) {
                    console.log(`ðŸŽ° Animation SLOT-MACHINE: ${previousSubCount} â†’ ${goal.current} (${absDelta} unitÃ©s)`);
                    // Vider la queue et faire une animation directe
                    animationQueue = [];
                    animateSlotMachine(previousSubCount, goal.current, goal, direction);
                } else {
                    console.log(`ðŸ“ Animation PROGRESSIVE: ${previousSubCount} â†’ ${goal.current}`);
                    // Animation progressive normale pour changement unique
                    animationQueue.push({
                        from: previousSubCount,
                        to: goal.current,
                        goal: goal,
                        direction: direction
                    });

                    if (!isAnimating) {
                        isAnimating = true;
                        const animation = animationQueue.shift();
                        animateCounterProgressive(animation.from, animation.to, animation.goal, animation.direction);
                    }
                }
            } else {
                displayGoalText(goal);
            }

            previousSubCount = goal.current;
            console.log('ðŸ“Š Followgoal mis Ã  jour');
        }
        
                /**
         * Animation SLOT-MACHINE pour les changements groupÃ©s
         * Effet de dÃ©filement sÃ©quentiel : 390 â†’ 391 â†’ 392 â†’ ... â†’ 401
         * AccÃ©lÃ¨re au dÃ©but, ralentit vers la fin (easing)
         */
        function animateSlotMachine(from, to, goal, direction) {
            console.log(`ðŸŽ° DÃ©marrage slot-machine: ${from} â†’ ${to}`);
            isAnimating = true;
            
            const delta = to - from;
            const totalSteps = Math.abs(delta);
            const step = delta > 0 ? 1 : -1; // +1 ou -1 selon la direction
            
            // DurÃ©e totale adaptÃ©e au nombre d'Ã©tapes (min 500ms, max 1500ms)
            const totalDuration = Math.min(Math.max(totalSteps * 80, 500), 1500);
            
            let currentValue = from;
            let stepIndex = 0;
            
            console.log(`ðŸ”¢ ${totalSteps} Ã©tapes Ã  afficher en ${totalDuration}ms`);
            
            function easeInOutQuad(t) {
                // AccÃ©lÃ¨re au dÃ©but, ralentit Ã  la fin
                return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            }
            
            function getDelayForStep(index, total) {
                // Calculer le dÃ©lai pour cette Ã©tape basÃ© sur l'easing
                // Plus rapide au milieu, plus lent au dÃ©but et Ã  la fin
                const progressBefore = index / total;
                const progressAfter = (index + 1) / total;
                const easedBefore = easeInOutQuad(progressBefore);
                const easedAfter = easeInOutQuad(progressAfter);
                const stepDuration = (easedAfter - easedBefore) * totalDuration;
                
                // Minimum 30ms entre chaque Ã©tape pour que ce soit visible
                return Math.max(stepDuration, 30);
            }
            
            function displayStep() {
                // Afficher la valeur actuelle
                animationDirection = direction;
                const intermediateGoal = { ...goal, current: currentValue };
                displayGoalText(intermediateGoal);
                
                // Passer Ã  l'Ã©tape suivante
                if (currentValue !== to) {
                    currentValue += step;
                    stepIndex++;
                    
                    const delay = getDelayForStep(stepIndex, totalSteps);
                    setTimeout(displayStep, delay);
                } else {
                    // Animation terminÃ©e
                    finishAnimation();
                }
            }
            
            function finishAnimation() {
                // S'assurer que la valeur finale est affichÃ©e
                animationDirection = direction;
                displayGoalText(goal);
                
                console.log(`âœ… Slot-machine terminÃ©e: ${to}`);
                isAnimating = false;
                
                // Traiter la file d'attente si nÃ©cessaire
                if (animationQueue.length > 0) {
                    const next = animationQueue.shift();
                    isAnimating = true;
                    animateCounterProgressive(next.from, next.to, next.goal, next.direction);
                }
            }
            
            // DÃ©marrer le dÃ©filement
            displayStep();
        }
function forceRecalculateDisplay() {
            console.log(' Recalcul forcé des dimensions avec la police actuelle');
            const currentDisplayText = currentText;
            currentText = "";
            counterEl.innerHTML = "";
            void counterEl.offsetHeight;
            updateCounter(currentDisplayText);
        }
        
        connectWebSocket();
        setTimeout(fetchCurrentData, 1000);
        setTimeout(() => {
            console.log('🔄 Refresh complet - recalcul des dimensions...');
            forceRecalculateDisplay();
        }, 15000);
    </script>
</body>
</html>


