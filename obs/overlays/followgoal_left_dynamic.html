<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <title>Followgoal Left - Dynamic Config</title>
    <style>
        @font-face {
            font-family: 'SEA';
            src: local('SEA'), url('SEA.ttf') format('truetype');
            font-display: swap;
        }
        
        :root {
            /* Variables CSS dynamiques (modifiÃ©es par le serveur JS) */
            --font-family: 'SEA';
            --font-size: 64px;
            --font-weight: normal;
            --text-color: white;
            --shadow-color: rgba(0,0,0,0.5);
            --stroke-color: black;
            --anim-duration: 1s;
            --anim-easing: cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --padding-left: 20px;
            --gap: 0;
        }
        
        body {
            background: transparent;
            margin: 0;
            font-family: var(--font-family), monospace;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            height: 100vh;
            color: var(--text-color);
            padding-left: var(--padding-left);
            padding-right: 0;
        }

        .counter {
            display: flex;
            font-size: var(--font-size);
            font-weight: var(--font-weight);
            gap: var(--gap);
            white-space: pre;
            text-shadow: 3px 3px 3px var(--shadow-color);
            -webkit-text-stroke: 1px var(--stroke-color);
        }

        .digit-container {
            position: relative;
            width: auto;
            min-width: 0.3em;
            height: 1.3em;
            overflow: hidden;
            display: inline-block;
        }

        .space-container {
            width: 0.25em;
            display: inline-block;
        }

        .digit {
            position: absolute;
            width: auto;
            white-space: nowrap;
            left: 0;
            text-align: left;
            transition: transform var(--anim-duration) var(--anim-easing);
        }

        .old {
            transform: translateY(0);
        }

        .new {
            transform: translateY(-100%);
        }

        .animate .old {
            animation: none;
        }

        .animate .new {
            animation: none;
        }

        @keyframes slideOut {
            0%   { transform: translateY(0); }
            100% { transform: translateY(100%); }
        }

        @keyframes slideIn {
            0%   { transform: translateY(-100%); }
            100% { transform: translateY(0); }
        }

        @keyframes slideOutUp {
            0%   { transform: translateY(0); }
            100% { transform: translateY(-100%); }
        }

        @keyframes slideInUp {
            0%   { transform: translateY(100%); }
            100% { transform: translateY(0); }
        }

        .animate-down .old {
            animation: slideOut 0.4s forwards ease-in-out;
        }

        .animate-down .new {
            animation: slideIn 0.4s forwards ease-in-out;
        }

        .animate-up .old {
            animation: slideOutUp 0.4s forwards ease-in-out;
        }

        .animate-up .new {
            animation: slideInUp 0.4s forwards ease-in-out;
        }
    </style>
</head>
<body>
    <div class="counter" id="counter">Chargement...</div>

    <script>
        // ==================================================================
        // ðŸŽ¨ CONNEXION WEBSOCKET POUR CONFIGURATION DYNAMIQUE
        // ==================================================================
        
        let configWs = null;
        
        function connectConfigWebSocket() {
            try {
                configWs = new WebSocket('ws://localhost:8084');
                
                configWs.onopen = () => {
                    console.log('âœ… Config WebSocket connectÃ© (port 8084)');
                };
                
                configWs.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'config_update' && data.config) {
                            console.log('ðŸŽ¨ Configuration reÃ§ue:', data.config);
                            applyConfig(data.config);
                        }
                    } catch (error) {
                        console.error('âŒ Erreur parsing config:', error);
                    }
                };
                
                configWs.onerror = (error) => {
                    console.error('âŒ Erreur Config WebSocket:', error);
                };
                
                configWs.onclose = () => {
                    console.log('ðŸ”Œ Config WebSocket dÃ©connectÃ©, reconnexion dans 5s...');
                    setTimeout(connectConfigWebSocket, 5000);
                };
            } catch (error) {
                console.error('âŒ Erreur connexion Config WebSocket:', error);
                setTimeout(connectConfigWebSocket, 5000);
            }
        }
        
        function applyConfig(config) {
            const root = document.documentElement;
            
            // Appliquer la police
            if (config.font) {
                if (config.font.family) root.style.setProperty('--font-family', config.font.family);
                if (config.font.size) root.style.setProperty('--font-size', config.font.size);
                if (config.font.weight) root.style.setProperty('--font-weight', config.font.weight);
            }
            
            // Appliquer les couleurs
            if (config.colors) {
                if (config.colors.text) root.style.setProperty('--text-color', config.colors.text);
                if (config.colors.shadow) root.style.setProperty('--shadow-color', config.colors.shadow);
                if (config.colors.stroke) root.style.setProperty('--stroke-color', config.colors.stroke);
            }
            
            // Appliquer l'animation
            if (config.animation) {
                if (config.animation.duration) root.style.setProperty('--anim-duration', config.animation.duration);
                if (config.animation.easing) root.style.setProperty('--anim-easing', config.animation.easing);
            }
            
            // Appliquer la mise en page
            if (config.layout) {
                if (config.layout.paddingLeft) root.style.setProperty('--padding-left', config.layout.paddingLeft);
                if (config.layout.gap) root.style.setProperty('--gap', config.layout.gap);
            }
            
            console.log('âœ… Configuration appliquÃ©e avec succÃ¨s');
            
            // Forcer le rafraÃ®chissement de l'affichage
            setTimeout(forceRecalculateDisplay, 100);
        }
        
        async function loadInitialConfig() {
            try {
                const response = await fetch('http://localhost:8082/api/overlay-config');
                if (response.ok) {
                    const config = await response.json();
                    console.log('ðŸŽ¨ Configuration initiale chargÃ©e:', config);
                    applyConfig(config);
                }
            } catch (error) {
                console.error('âŒ Erreur chargement config initiale:', error);
            }
        }
        
        // Charger la config initiale puis connecter le WebSocket
        loadInitialConfig();
        connectConfigWebSocket();
        
        // ==================================================================
        // RESTE DU CODE ORIGINAL (WebSocket compteur, animations, etc.)
        // ==================================================================
        
        let ws;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        const counterEl = document.getElementById("counter");
        let currentText = "";
        let previousSubCount = null;
        let animationDirection = "down";
        let currentFollowgoal = null;
        let isAnimating = false;
        let animationQueue = [];

        function createDigitElement(char, className, delay) {
            const div = document.createElement("div");
            div.className = className + " digit";
            div.textContent = char;
            div.style.animationDelay = `${delay}ms`;
            return div;
        }

                function updateCounter(newText) {
            if (newText === currentText) return;

            const chars = newText.split("");
            counterEl.innerHTML = "";
            // Créer un canvas pour mesure ultra-précise (méthode la plus fiable)
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Récupérer les styles CSS variables actuels
            const rootStyles = getComputedStyle(document.documentElement);
            const counterStyles = getComputedStyle(counterEl);
            
            const fontSize = rootStyles.getPropertyValue('--font-size').trim();
            const fontFamily = rootStyles.getPropertyValue('--font-family').trim();
            const fontWeight = rootStyles.getPropertyValue('--font-weight').trim() || 'normal';
            
            // Construire la chaîne font pour canvas (format: "weight size family")
            const fontString = `${fontWeight} ${fontSize} ${fontFamily}`;
            ctx.font = fontString;
            
            console.log(` Mesure CANVAS avec: ${fontString}`);

            const totalChars = Math.max(chars.length, currentText.length);
            let changedCount = 0;

            for (let i = 0; i < totalChars; i++) {
                if ((currentText[i] || "") !== (chars[i] || "")) {
                    changedCount++;
                }
            }

            const changeRatio = changedCount / totalChars;
            const isFullReset = changeRatio > 0.5;

            chars.forEach((char, index) => {
                if (char === " ") {
                    const spaceContainer = document.createElement("div");
                    spaceContainer.className = "space-container";
                    spaceContainer.innerHTML = "&nbsp;";
                    counterEl.appendChild(spaceContainer);
                } else {
                    const container = document.createElement("div");
                    container.className = "digit-container";

                    // Mesurer la largeur avec canvas.measureText() (ultra-précis)
                    const metrics = ctx.measureText(char);
                    const charWidth = metrics.width;
                    
                    // Note: text-shadow et stroke ajoutent ~4-6px visuellement
                    const shadowStrokeOffset = 5;
                    container.style.width = `${Math.max(charWidth + shadowStrokeOffset, 10)}px`;

                    const currentChar = currentText[index] || "";
                    const charChanged = char !== currentChar;
                    const delay = isFullReset ? 0 : index * 50;

                    if (!charChanged && !isFullReset) {
                        const staticDigit = createDigitElement(char, "static", 0);
                        staticDigit.style.transform = "translateY(0)";
                        container.appendChild(staticDigit);
                    } else {
                        const oldDigit = createDigitElement(currentChar === " " ? " " : currentChar, "old", delay);
                        const newDigit = createDigitElement(char, "new", delay);

                        container.appendChild(oldDigit);
                        container.appendChild(newDigit);
                        container.classList.add("animate");
                        container.classList.add(`animate-${animationDirection}`);
                    }

                    counterEl.appendChild(container);
                }
            });

            // Plus besoin de removeChild (on n'utilise plus measureDiv)
            currentText = newText;
        }
        
        function animateCounterProgressive(fromCount, toCount, goal) {
            const steps = Math.abs(toCount - fromCount);
            
            if (steps === 0) {
                displayGoalText(goal);
                return;
            }
            
            const totalDuration = 1000;
            const startTime = performance.now();
            const updateInterval = totalDuration / Math.max(steps, 60);
            
            console.log(`ðŸŽ° Animation: ${fromCount} â†’ ${toCount} (${steps} Ã©tapes)`);
            
            let lastDisplayedValue = fromCount;
            
            function easeOutCubic(t) {
                return 1 - Math.pow(1 - t, 3);
            }
            
            function animate(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / totalDuration, 1);
                const easedProgress = easeOutCubic(progress);
                const currentValue = Math.round(fromCount + (toCount - fromCount) * easedProgress);
                
                if (currentValue !== lastDisplayedValue || progress === 1) {
                    lastDisplayedValue = currentValue;
                    const intermediateGoal = { ...goal, current: currentValue };
                    displayGoalText(intermediateGoal);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    const finalGoal = { ...goal, current: toCount };
                    displayGoalText(finalGoal);
                    isAnimating = false;
                    processAnimationQueue();
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function displayGoalText(goal) {
            let displayText;
            
            if (goal.isMaxReached) {
                displayText = goal.current.toString();
            } else {
                if (!goal.message || goal.message.trim() === '') {
                    displayText = `${goal.current}/${goal.target}`;
                } else {
                    displayText = `${goal.current}/${goal.target} : ${goal.message}`;
                }
            }
            
            updateCounter(displayText);
        }
        
        function processAnimationQueue() {
            if (animationQueue.length > 0 && !isAnimating) {
                const nextAnimation = animationQueue.shift();
                isAnimating = true;
                animateCounterProgressive(nextAnimation.from, nextAnimation.to, nextAnimation.goal);
            }
        }

        function connectWebSocket() {
            try {
                ws = new WebSocket('ws://localhost:8083');

                ws.onopen = () => {
                    console.log('âœ… ConnectÃ© au WebSocket (compteur)');
                    reconnectAttempts = 0;
                    fetchCurrentData();
                };

                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        if (data.type === 'follow_update' && data.goal) {
                            updateFollowgoal(data.goal);
                        }
                    } catch (error) {
                        console.error('âŒ Erreur parsing message:', error);
                    }
                };

                ws.onerror = (error) => {
                    console.error('âŒ Erreur WebSocket (compteur):', error);
                };

                ws.onclose = () => {
                    console.log('ðŸ”Œ WebSocket compteur dÃ©connectÃ©, reconnexion dans 3s...');
                    setTimeout(connectWebSocket, 3000);
                };
            } catch (error) {
                console.error('âŒ Erreur connexion WebSocket:', error);
                setTimeout(connectWebSocket, 3000);
            }
        }
        
        async function fetchCurrentData() {
            try {
                const cacheBuster = Date.now();
                const response = await fetch(`http://localhost:8082/api/follow_goal?_=${cacheBuster}`);
                if (response.ok) {
                    const data = await response.json();
                    updateFollowgoal(data.goal);
                }
            } catch (error) {
                console.error('âŒ Erreur rÃ©cupÃ©ration donnÃ©es FOLLOW goal:', error);
            }
        }
        
        function updateFollowgoal(goal) {
            currentFollowgoal = goal;
            
            if (previousSubCount !== null && goal.current !== previousSubCount) {
                animationDirection = goal.current > previousSubCount ? "down" : "up";
                console.log(`ðŸ”„ Direction: ${animationDirection} (${previousSubCount} â†’ ${goal.current})`);
                
                animationQueue.push({
                    from: previousSubCount,
                    to: goal.current,
                    goal: goal
                });
                
                if (!isAnimating) {
                    isAnimating = true;
                    const animation = animationQueue.shift();
                    animateCounterProgressive(animation.from, animation.to, animation.goal);
                }
            } else {
                displayGoalText(goal);
            }
            
            previousSubCount = goal.current;
            console.log('ðŸ“Š Followgoal mis Ã  jour');
        }
        
        function forceRecalculateDisplay() {
            console.log(' Recalcul forcé des dimensions avec la police actuelle');
            const currentDisplayText = currentText;
            currentText = "";
            counterEl.innerHTML = "";
            void counterEl.offsetHeight;
            updateCounter(currentDisplayText);
        }
        
        connectWebSocket();
        setTimeout(fetchCurrentData, 1000);
        setTimeout(() => {
            console.log('ðŸ”„ Refresh complet - recalcul des dimensions...');
            forceRecalculateDisplay();
        }, 15000);
    </script>
</body>
</html>

